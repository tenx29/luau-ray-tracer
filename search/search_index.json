{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About Luau Ray Tracer Luau Ray Tracer is an open-source object-oriented path tracing module for Luau. Info Basic understanding of Luau and object-oriented programming is assumed in this documentation. Performance notice Ray tracing is a very time-consuming process, especially when it's ran on a CPU. Roblox has no way to run shader code on a GPU, so this module is not optimized for performance. Using this module in real-time is not recommended.","title":"About"},{"location":"#about-luau-ray-tracer","text":"Luau Ray Tracer is an open-source object-oriented path tracing module for Luau. Info Basic understanding of Luau and object-oriented programming is assumed in this documentation. Performance notice Ray tracing is a very time-consuming process, especially when it's ran on a CPU. Roblox has no way to run shader code on a GPU, so this module is not optimized for performance. Using this module in real-time is not recommended.","title":"About Luau Ray Tracer"},{"location":"api-reference/post-processing-shader/","text":"arg { color: grey; font-style: italic; } Post Processing Shader A PostProcessingShader is a shader that is applied to the screen after the scene is rendered. Post-processing shaders cannot be used to modify Traced Rays, but they can be used to modify all Ray Tracer buffers. Post-processing shaders have access to all pixels in every buffer at once, and can modify them in any way they want. Creating a Post Processing Shader Shader Shader.new( function shaderFunction , table attributes? ) Creates a new Post Processing Shader. shaderFunction is the function to call when the shader is applied. attributes is a table of attributes to pass to the shader. Properties function Function The function to call when the shader is applied. Note The shader function is expected to return nil or all buffers in a dictionary. table Attributes Optional user-defined attributes to pass to the shader. Methods dict Process( RayTracer , ... ) Processes the shader. ... is a list of optional arguments to pass to the shader. Note The shader function is expected to return nil or all buffers in a dictionary. table < Vector2 > GetAdjacentPixels( Vector2 pixel , Vector2 resolution , int radius ) Returns a list of adjacent pixel coordinates to pixel . resolution is the resolution of the buffer. radius is the radius of the search. Note The shape of the search area is always a square.","title":"Post Processing Shader"},{"location":"api-reference/post-processing-shader/#post-processing-shader","text":"A PostProcessingShader is a shader that is applied to the screen after the scene is rendered. Post-processing shaders cannot be used to modify Traced Rays, but they can be used to modify all Ray Tracer buffers. Post-processing shaders have access to all pixels in every buffer at once, and can modify them in any way they want.","title":"Post Processing Shader"},{"location":"api-reference/post-processing-shader/#creating-a-post-processing-shader","text":"","title":"Creating a Post Processing Shader"},{"location":"api-reference/post-processing-shader/#shader-shadernewfunction-shaderfunction-table-attributes","text":"Creates a new Post Processing Shader. shaderFunction is the function to call when the shader is applied. attributes is a table of attributes to pass to the shader.","title":"Shader Shader.new(function shaderFunction, table attributes?)"},{"location":"api-reference/post-processing-shader/#properties","text":"","title":"Properties"},{"location":"api-reference/post-processing-shader/#function-function","text":"The function to call when the shader is applied. Note The shader function is expected to return nil or all buffers in a dictionary.","title":"function Function"},{"location":"api-reference/post-processing-shader/#table-attributes","text":"Optional user-defined attributes to pass to the shader.","title":"table Attributes"},{"location":"api-reference/post-processing-shader/#methods","text":"","title":"Methods"},{"location":"api-reference/post-processing-shader/#dict-processraytracer","text":"Processes the shader. ... is a list of optional arguments to pass to the shader. Note The shader function is expected to return nil or all buffers in a dictionary.","title":"dict Process(RayTracer, ...)"},{"location":"api-reference/post-processing-shader/#tablevector2-getadjacentpixelsvector2-pixel-vector2-resolution-int-radius","text":"Returns a list of adjacent pixel coordinates to pixel . resolution is the resolution of the buffer. radius is the radius of the search. Note The shape of the search area is always a square.","title":"table&lt;Vector2&gt; GetAdjacentPixels(Vector2 pixel, Vector2 resolution, int radius)"},{"location":"api-reference/ray-tracer/","text":"arg { color: grey; font-style: italic; } Ray Tracer The Ray Tracer is a class that handles emitting rays and collecting scene information into different buffers. Important The Ray Tracer needs a Ray Tracing Camera to be able to render a scene. Creating a Ray Tracer RayTracer RayTracer.new( RayTracingCamera camera , int maxBounces? [=1] , table < Shader > shaders? , table < PostProcessingShader > postProcessingShaders? , RaycastParams raycastParams? ) Creates a new RayTracer. camera is the camera that will be used to render the scene. maxBounces? is the maximum number of bounces that will be performed. If maxBounces is not provided, 1 will be used. shaders? is a table of shaders that will be used to render the scene. postProcessingShaders? is a table of post-processing shaders that will be used to render the scene. raycastParams? is the raycast parameters that will be used to raycast the scene. Properties RayTracingCamera Camera The RayTracingCamera that is used to render the scene. int MaxBounces The maximum number of bounces that will be performed. Defaults to 1. table < Shader > Shaders The shaders that will be used to render the scene. Defaults to an empty table. table < PostProcessingShader > PostProcessingShaders The post-processing shaders that will be used to render the scene. Defaults to an empty table. Post-processing shaders are applied after the scene is rendered. dict { 2D table < Color3 > Color , 2D table < float > Depth , 2D table < Color3 > Normal } Buffers The buffers that will be used to render the scene. Each buffer is a 2D table where the first index is the x-coordinate and the second index is the y-coordinate. Buffers are usually accessed by post-processing shaders. Methods void ClearBuffers() Clears all buffers of the RayTracer. 2D table < Color3 > Render() Clears all buffers and renders the scene. Returns the color buffer after the render is complete. Note Post-processing shaders are not applied in this method. To apply post-processing shaders, use the PostProcess method after the initial render is complete. dict PostProcess( ... ) Applies post-processing shaders to the scene. ... is any number of arguments passed to the post-processing shaders. Returns all buffers after the post-processing shaders are applied. Color3 GetPixel( int x , int y ) Gets the color of the pixel at x , y from the color buffer. void SetPixel( int x , int y , Color3 color ) Sets the color of the pixel at x , y in the color buffer. Color3 VisualizeNormal( Vector3 normal ) Visualizes a unit vector normal as a color.","title":"Ray Tracer"},{"location":"api-reference/ray-tracer/#ray-tracer","text":"The Ray Tracer is a class that handles emitting rays and collecting scene information into different buffers. Important The Ray Tracer needs a Ray Tracing Camera to be able to render a scene.","title":"Ray Tracer"},{"location":"api-reference/ray-tracer/#creating-a-ray-tracer","text":"","title":"Creating a Ray Tracer"},{"location":"api-reference/ray-tracer/#raytracer-raytracernewraytracingcamera-camera-int-maxbounces-1-tableshader-shaders-tablepostprocessingshader-postprocessingshaders-raycastparams-raycastparams","text":"Creates a new RayTracer. camera is the camera that will be used to render the scene. maxBounces? is the maximum number of bounces that will be performed. If maxBounces is not provided, 1 will be used. shaders? is a table of shaders that will be used to render the scene. postProcessingShaders? is a table of post-processing shaders that will be used to render the scene. raycastParams? is the raycast parameters that will be used to raycast the scene.","title":"RayTracer RayTracer.new(RayTracingCamera camera, int maxBounces? [=1], table&lt;Shader&gt; shaders?, table&lt;PostProcessingShader&gt; postProcessingShaders?, RaycastParams raycastParams?)"},{"location":"api-reference/ray-tracer/#properties","text":"","title":"Properties"},{"location":"api-reference/ray-tracer/#raytracingcamera-camera","text":"The RayTracingCamera that is used to render the scene.","title":"RayTracingCamera Camera"},{"location":"api-reference/ray-tracer/#int-maxbounces","text":"The maximum number of bounces that will be performed. Defaults to 1.","title":"int MaxBounces"},{"location":"api-reference/ray-tracer/#tableshader-shaders","text":"The shaders that will be used to render the scene. Defaults to an empty table.","title":"table&lt;Shader&gt; Shaders"},{"location":"api-reference/ray-tracer/#tablepostprocessingshader-postprocessingshaders","text":"The post-processing shaders that will be used to render the scene. Defaults to an empty table. Post-processing shaders are applied after the scene is rendered.","title":"table&lt;PostProcessingShader&gt; PostProcessingShaders"},{"location":"api-reference/ray-tracer/#dict-2d-tablecolor3-color-2d-tablefloat-depth-2d-tablecolor3-normal-buffers","text":"The buffers that will be used to render the scene. Each buffer is a 2D table where the first index is the x-coordinate and the second index is the y-coordinate. Buffers are usually accessed by post-processing shaders.","title":"dict {2D table&lt;Color3&gt; Color, 2D table&lt;float&gt; Depth, 2D table&lt;Color3&gt; Normal} Buffers"},{"location":"api-reference/ray-tracer/#methods","text":"","title":"Methods"},{"location":"api-reference/ray-tracer/#void-clearbuffers","text":"Clears all buffers of the RayTracer.","title":"void ClearBuffers()"},{"location":"api-reference/ray-tracer/#2d-tablecolor3-render","text":"Clears all buffers and renders the scene. Returns the color buffer after the render is complete. Note Post-processing shaders are not applied in this method. To apply post-processing shaders, use the PostProcess method after the initial render is complete.","title":"2D table&lt;Color3&gt; Render()"},{"location":"api-reference/ray-tracer/#dict-postprocess","text":"Applies post-processing shaders to the scene. ... is any number of arguments passed to the post-processing shaders. Returns all buffers after the post-processing shaders are applied.","title":"dict PostProcess(...)"},{"location":"api-reference/ray-tracer/#color3-getpixelint-x-int-y","text":"Gets the color of the pixel at x , y from the color buffer.","title":"Color3 GetPixel(int x, int y)"},{"location":"api-reference/ray-tracer/#void-setpixelint-x-int-y-color3-color","text":"Sets the color of the pixel at x , y in the color buffer.","title":"void SetPixel(int x, int y, Color3 color)"},{"location":"api-reference/ray-tracer/#color3-visualizenormalvector3-normal","text":"Visualizes a unit vector normal as a color.","title":"Color3 VisualizeNormal(Vector3 normal)"},{"location":"api-reference/ray-tracing-camera/","text":"arg { color: grey; font-style: italic; } Ray Tracing Camera The RayTracingCamera is a special camera class that can be used to render a scene using ray tracing. The camera provides the necessary functions to render a scene using ray tracing. Warning RayTracingCamera can not be used as a normal camera. Creating a RayTracingCamera RayTracingCamera RayTracingCamera.new( Vector2 resolution , float fieldOfView , float farPlane , CFrame CFrame ) Creates a new RayTracingCamera. resolution is the camera viewport's size in pixels. fieldOfView is the camera's field of view in radians. farPlane is the distance to the far plane. CFrame is the camera's position and orientation. Important The RayTracingCamera acts as the origin point for the rays. This means that the camera's position and orientation must be set before the camera is used to render a scene. Note The camera does not do any rendering itself. It only provides the necessary functions to render a scene using ray tracing. Images can be rendered using the Raytracer class. Properties Vector2 Resolution The resolution of the camera viewport in pixels. float FieldOfView The camera's field of view in radians. float FarPlane The distance to the far plane. CFRame CFrame The camera's position and orientation. Methods Vector3 GetPixelDirection( Vector2 pixel ) Returns the direction of the ray that goes through the given pixel. { Vector3 origin , Vector3 direction } GetInitialRay( Vector2 pixel ) Returns the origin and direction of the ray that goes through the given pixel.","title":"Ray Tracing Camera"},{"location":"api-reference/ray-tracing-camera/#ray-tracing-camera","text":"The RayTracingCamera is a special camera class that can be used to render a scene using ray tracing. The camera provides the necessary functions to render a scene using ray tracing. Warning RayTracingCamera can not be used as a normal camera.","title":"Ray Tracing Camera"},{"location":"api-reference/ray-tracing-camera/#creating-a-raytracingcamera","text":"","title":"Creating a RayTracingCamera"},{"location":"api-reference/ray-tracing-camera/#raytracingcamera-raytracingcameranewvector2-resolution-float-fieldofview-float-farplane-cframe-cframe","text":"Creates a new RayTracingCamera. resolution is the camera viewport's size in pixels. fieldOfView is the camera's field of view in radians. farPlane is the distance to the far plane. CFrame is the camera's position and orientation. Important The RayTracingCamera acts as the origin point for the rays. This means that the camera's position and orientation must be set before the camera is used to render a scene. Note The camera does not do any rendering itself. It only provides the necessary functions to render a scene using ray tracing. Images can be rendered using the Raytracer class.","title":"RayTracingCamera RayTracingCamera.new(Vector2 resolution, float fieldOfView, float farPlane, CFrame CFrame )"},{"location":"api-reference/ray-tracing-camera/#properties","text":"","title":"Properties"},{"location":"api-reference/ray-tracing-camera/#vector2-resolution","text":"The resolution of the camera viewport in pixels.","title":"Vector2 Resolution"},{"location":"api-reference/ray-tracing-camera/#float-fieldofview","text":"The camera's field of view in radians.","title":"float FieldOfView"},{"location":"api-reference/ray-tracing-camera/#float-farplane","text":"The distance to the far plane.","title":"float FarPlane"},{"location":"api-reference/ray-tracing-camera/#cframe-cframe","text":"The camera's position and orientation.","title":"CFRame CFrame"},{"location":"api-reference/ray-tracing-camera/#methods","text":"","title":"Methods"},{"location":"api-reference/ray-tracing-camera/#vector3-getpixeldirectionvector2-pixel","text":"Returns the direction of the ray that goes through the given pixel.","title":"Vector3 GetPixelDirection(Vector2 pixel)"},{"location":"api-reference/ray-tracing-camera/#vector3-origin-vector3-direction-getinitialrayvector2-pixel","text":"Returns the origin and direction of the ray that goes through the given pixel.","title":"{Vector3 origin, Vector3 direction} GetInitialRay(Vector2 pixel)"},{"location":"api-reference/render-pipeline/","text":"Render pipeline Luau Ray Tracer uses a relatively simple path tracer to render images. The path tracer is implemented as a recursive function that traces rays from the camera to the scene. Ray bounces are created using user-defined shader objects. flowchart LR subgraph Traced Ray A[Ray] --> B[Termination data]; B --> C[Shaders]; C -.-> R[Bounced Rays]; C --> D[Color]; R -.-> D; end subgraph Ray Tracer Buffers E[Color]; F[Depth]; G[Normal]; end D --> E; B ----> F; B ----> G; E & F & G <---> H[Post-processing shaders];","title":"The Render Pipeline"},{"location":"api-reference/render-pipeline/#render-pipeline","text":"Luau Ray Tracer uses a relatively simple path tracer to render images. The path tracer is implemented as a recursive function that traces rays from the camera to the scene. Ray bounces are created using user-defined shader objects. flowchart LR subgraph Traced Ray A[Ray] --> B[Termination data]; B --> C[Shaders]; C -.-> R[Bounced Rays]; C --> D[Color]; R -.-> D; end subgraph Ray Tracer Buffers E[Color]; F[Depth]; G[Normal]; end D --> E; B ----> F; B ----> G; E & F & G <---> H[Post-processing shaders];","title":"Render pipeline"},{"location":"api-reference/shader/","text":"arg { color: grey; font-style: italic; } Shader A Shader is an object that is used to modify the behavior of a ray. It is applied to the ray when it is traced. Each shader is applied to a ray in the order they are in the ray's shader table. Because a shader is applied to each ray individually, they cannot be used to modify the adjacent pixels. Creating a Shader Shader Shader.new( function shaderFunction , table attributes? ) Creates a new Shader. shaderFunction is the function to call when the shader is applied. attributes is a table of attributes to pass to the shader. Properties function Function The function to call when the shader is applied. Note The shader function is expected to return a Color3. table Attributes Optional user-defined attributes to pass to the shader. Methods Color3 Process( TracedRay tracedRay , RaycastResult raycastResult , ... ) Process the shader on the ray. tracedRay is the ray that is being processed. raycastResult is the result of the raycast. ... is any additional arguments passed to the shader. TracedRay Continue( TracedRay tracedRay , RaycastResult raycastResult ) Continues the ray after it has been processed by the shader. tracedRay is the ray that is being processed. raycastResult is the result of the raycast. Note This method will continue the ray in the same direction as the ray's previous direction. For more fine control over how the ray is continued, create a new TracedRay manually in a shader. TracedRay Reflect( TracedRay tracedRay , RaycastResult raycastResult , Vector3 normal ) Reflects the ray. tracedRay is the ray that is being processed. raycastResult is the result of the raycast. normal is the normal of the surface the ray hit. TracedRay Refract( TracedRay tracedRay , RaycastResult raycastResult , Vector3 normal , number indexOfRefraction )]) Refracts the ray. tracedRay is the ray that is being processed. raycastResult is the result of the raycast. normal is the normal of the surface the ray hit. indexOfRefraction is the index of refraction of the material the ray hit. Vector3 , float SimpleIntersect( Vector3 origin , Vector3 direction , Instance object ) Calculates the intersection end point and length of a ray through an object based on its outermost geometry. origin is the origin of the ray. direction is the direction of the ray. Vector3 , float ComplexIntersect( Vector3 origin , Vector3 direction , Instance object ) Calculates the first intersection end point and length of a ray through an object based on its true geometry. origin is the origin of the ray. direction is the direction of the ray. This method is more accurate than SimpleIntersect but is slower.","title":"Shader"},{"location":"api-reference/shader/#shader","text":"A Shader is an object that is used to modify the behavior of a ray. It is applied to the ray when it is traced. Each shader is applied to a ray in the order they are in the ray's shader table. Because a shader is applied to each ray individually, they cannot be used to modify the adjacent pixels.","title":"Shader"},{"location":"api-reference/shader/#creating-a-shader","text":"","title":"Creating a Shader"},{"location":"api-reference/shader/#shader-shadernewfunction-shaderfunction-table-attributes","text":"Creates a new Shader. shaderFunction is the function to call when the shader is applied. attributes is a table of attributes to pass to the shader.","title":"Shader Shader.new(function shaderFunction, table attributes?)"},{"location":"api-reference/shader/#properties","text":"","title":"Properties"},{"location":"api-reference/shader/#function-function","text":"The function to call when the shader is applied. Note The shader function is expected to return a Color3.","title":"function Function"},{"location":"api-reference/shader/#table-attributes","text":"Optional user-defined attributes to pass to the shader.","title":"table Attributes"},{"location":"api-reference/shader/#methods","text":"","title":"Methods"},{"location":"api-reference/shader/#color3-processtracedray-tracedray-raycastresult-raycastresult","text":"Process the shader on the ray. tracedRay is the ray that is being processed. raycastResult is the result of the raycast. ... is any additional arguments passed to the shader.","title":"Color3 Process(TracedRay tracedRay, RaycastResult raycastResult, ...)"},{"location":"api-reference/shader/#tracedray-continuetracedray-tracedray-raycastresult-raycastresult","text":"Continues the ray after it has been processed by the shader. tracedRay is the ray that is being processed. raycastResult is the result of the raycast. Note This method will continue the ray in the same direction as the ray's previous direction. For more fine control over how the ray is continued, create a new TracedRay manually in a shader.","title":"TracedRay Continue(TracedRay tracedRay, RaycastResult raycastResult)"},{"location":"api-reference/shader/#tracedray-reflecttracedray-tracedray-raycastresult-raycastresult-vector3-normal","text":"Reflects the ray. tracedRay is the ray that is being processed. raycastResult is the result of the raycast. normal is the normal of the surface the ray hit.","title":"TracedRay Reflect(TracedRay tracedRay, RaycastResult raycastResult, Vector3 normal)"},{"location":"api-reference/shader/#tracedray-refracttracedray-tracedray-raycastresult-raycastresult-vector3-normal-number-indexofrefraction","text":"Refracts the ray. tracedRay is the ray that is being processed. raycastResult is the result of the raycast. normal is the normal of the surface the ray hit. indexOfRefraction is the index of refraction of the material the ray hit.","title":"TracedRay Refract(TracedRay tracedRay, RaycastResult raycastResult, Vector3 normal, number indexOfRefraction)])"},{"location":"api-reference/shader/#vector3-float-simpleintersectvector3-origin-vector3-direction-instance-object","text":"Calculates the intersection end point and length of a ray through an object based on its outermost geometry. origin is the origin of the ray. direction is the direction of the ray.","title":"Vector3, float SimpleIntersect(Vector3 origin, Vector3 direction, Instance object)"},{"location":"api-reference/shader/#vector3-float-complexintersectvector3-origin-vector3-direction-instance-object","text":"Calculates the first intersection end point and length of a ray through an object based on its true geometry. origin is the origin of the ray. direction is the direction of the ray. This method is more accurate than SimpleIntersect but is slower.","title":"Vector3, float ComplexIntersect(Vector3 origin, Vector3 direction, Instance object)"},{"location":"api-reference/traced-ray/","text":"arg { color: grey; font-style: italic; } Traced Ray A TracedRay is a ray that has been traced through a scene. The TracedRay handles the ray's position and orientation, as well as runs any shader effects on the ray. Warning This class is not meant to be used directly. Constructor TracedRay TracedRay.new( Vector3 origin , Vector3 direction , int maxBounces , RaycastParams raycastParams , table < Shader > shaders ) Creates a new TracedRay. maxBounces is the maximum number of bounces the ray can make. raycastParams is the raycast parameters to use when tracing the ray. shaders is a table of shader effects to apply to the ray. Properties Vector2 Pixel The viewport pixel the ray originates from. Color3 Color The color of the ray. int Bounces The number of bounces the ray has undergone. dict { float Distance , Vector3 Normal } InitialCollision The first collision the ray has undergone. Vector3 Origin The origin of the ray. Vector3 Direction The direction of the ray. int MaxBounces The maximum number of bounces the ray can undergo. RaycastParams RaycastParams The raycast parameters used to trace the ray. table < Shader > Shaders The shaders that the ray can run. Methods TracedRay Trace() Traces the ray and runs any shader effects when the ray terminates. Returns the TracedRay object itself.","title":"Traced Ray"},{"location":"api-reference/traced-ray/#traced-ray","text":"A TracedRay is a ray that has been traced through a scene. The TracedRay handles the ray's position and orientation, as well as runs any shader effects on the ray. Warning This class is not meant to be used directly.","title":"Traced Ray"},{"location":"api-reference/traced-ray/#constructor","text":"","title":"Constructor"},{"location":"api-reference/traced-ray/#tracedray-tracedraynewvector3-origin-vector3-direction-int-maxbounces-raycastparams-raycastparams-tableshader-shaders","text":"Creates a new TracedRay. maxBounces is the maximum number of bounces the ray can make. raycastParams is the raycast parameters to use when tracing the ray. shaders is a table of shader effects to apply to the ray.","title":"TracedRay TracedRay.new(Vector3 origin, Vector3 direction, int maxBounces, RaycastParams raycastParams, table&lt;Shader&gt; shaders)"},{"location":"api-reference/traced-ray/#properties","text":"","title":"Properties"},{"location":"api-reference/traced-ray/#vector2-pixel","text":"The viewport pixel the ray originates from.","title":"Vector2 Pixel"},{"location":"api-reference/traced-ray/#color3-color","text":"The color of the ray.","title":"Color3 Color"},{"location":"api-reference/traced-ray/#int-bounces","text":"The number of bounces the ray has undergone.","title":"int Bounces"},{"location":"api-reference/traced-ray/#dict-float-distance-vector3-normal-initialcollision","text":"The first collision the ray has undergone.","title":"dict {float Distance, Vector3 Normal} InitialCollision"},{"location":"api-reference/traced-ray/#vector3-origin","text":"The origin of the ray.","title":"Vector3 Origin"},{"location":"api-reference/traced-ray/#vector3-direction","text":"The direction of the ray.","title":"Vector3 Direction"},{"location":"api-reference/traced-ray/#int-maxbounces","text":"The maximum number of bounces the ray can undergo.","title":"int MaxBounces"},{"location":"api-reference/traced-ray/#raycastparams-raycastparams","text":"The raycast parameters used to trace the ray.","title":"RaycastParams RaycastParams"},{"location":"api-reference/traced-ray/#tableshader-shaders","text":"The shaders that the ray can run.","title":"table&lt;Shader&gt; Shaders"},{"location":"api-reference/traced-ray/#methods","text":"","title":"Methods"},{"location":"api-reference/traced-ray/#tracedray-trace","text":"Traces the ray and runs any shader effects when the ray terminates. Returns the TracedRay object itself.","title":"TracedRay Trace()"},{"location":"getting-started/advanced-shading/","text":"Advanced shading Here are some shading techniques that were not covered in the previous tutorials. Reflection Reflection is the process of bouncing a ray off of a surface. The Shader class has a method called Reflect that can be used to create a reflection ray easily. Let's create a shader that reflects rays off of any objects with the name 'Mirror'. Mirror shader example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -- ModuleScript local Shader = require ( script . Parent . Parent . classes . Shader ) local MirrorShader = Shader . new () MirrorShader . Function = function ( Ray , Hit , ...) -- If the ray didn't hit anything, skip this shader. if not Hit then return end -- Only apply the shader to objects whose name is 'Mirror'. if Hit . Instance . Name == 'Mirror' then -- Get the normal of the surface that was hit. local Normal = Hit . Normal -- Create a reflection ray and return the color of the reflected ray. -- The Reflect method will copy all shaders from the original ray to the new ray -- and handles bounce limiting. return Shader : Reflect ( Ray , Hit , Normal ). Color end end return MirrorShader Refraction Refraction is the process of bending a ray at the interface of two transparent objects. The Shader class has a method called Refract that can be used to create a refraction ray easily. Let's create a shader that refracts rays off of any objects with the name 'Glass'. Glass shader example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -- ModuleScript local Shader = require ( script . Parent . Parent . classes . Shader ) local GlassShader = Shader . new () GlassShader . Function = function ( Ray , Hit , ...) -- If the ray didn't hit anything, skip this shader. if not Hit then return end -- Only apply the shader to objects whose name is 'Glass'. if Hit . Instance . Name == 'Glass' then -- Get the normal of the surface that was hit. local Normal = Hit . Normal -- Create a refraction ray and return the color of the refracted ray. -- The Refract method will copy all shaders from the original ray to the new ray -- and handles bounce limiting. return Shader : Refract ( Ray , Hit , Normal , 1.5 ). Color end end return GlassShader Here's an example of what you can do with the Shader and PostProcessingShader classes. Disclaimers Important Remember to adjust your RayTracer MaxBounces setting to match the number of bounces you want. Warning Some shaders may produce noisier results than others. Path tracing is very sensitive to noise, which becomes more noticeable as a ray bounces more times.","title":"Advanced shading"},{"location":"getting-started/advanced-shading/#advanced-shading","text":"Here are some shading techniques that were not covered in the previous tutorials.","title":"Advanced shading"},{"location":"getting-started/advanced-shading/#reflection","text":"Reflection is the process of bouncing a ray off of a surface. The Shader class has a method called Reflect that can be used to create a reflection ray easily. Let's create a shader that reflects rays off of any objects with the name 'Mirror'. Mirror shader example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -- ModuleScript local Shader = require ( script . Parent . Parent . classes . Shader ) local MirrorShader = Shader . new () MirrorShader . Function = function ( Ray , Hit , ...) -- If the ray didn't hit anything, skip this shader. if not Hit then return end -- Only apply the shader to objects whose name is 'Mirror'. if Hit . Instance . Name == 'Mirror' then -- Get the normal of the surface that was hit. local Normal = Hit . Normal -- Create a reflection ray and return the color of the reflected ray. -- The Reflect method will copy all shaders from the original ray to the new ray -- and handles bounce limiting. return Shader : Reflect ( Ray , Hit , Normal ). Color end end return MirrorShader","title":"Reflection"},{"location":"getting-started/advanced-shading/#refraction","text":"Refraction is the process of bending a ray at the interface of two transparent objects. The Shader class has a method called Refract that can be used to create a refraction ray easily. Let's create a shader that refracts rays off of any objects with the name 'Glass'. Glass shader example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -- ModuleScript local Shader = require ( script . Parent . Parent . classes . Shader ) local GlassShader = Shader . new () GlassShader . Function = function ( Ray , Hit , ...) -- If the ray didn't hit anything, skip this shader. if not Hit then return end -- Only apply the shader to objects whose name is 'Glass'. if Hit . Instance . Name == 'Glass' then -- Get the normal of the surface that was hit. local Normal = Hit . Normal -- Create a refraction ray and return the color of the refracted ray. -- The Refract method will copy all shaders from the original ray to the new ray -- and handles bounce limiting. return Shader : Refract ( Ray , Hit , Normal , 1.5 ). Color end end return GlassShader Here's an example of what you can do with the Shader and PostProcessingShader classes.","title":"Refraction"},{"location":"getting-started/advanced-shading/#disclaimers","text":"Important Remember to adjust your RayTracer MaxBounces setting to match the number of bounces you want. Warning Some shaders may produce noisier results than others. Path tracing is very sensitive to noise, which becomes more noticeable as a ray bounces more times.","title":"Disclaimers"},{"location":"getting-started/buffers/","text":"Buffers The Color, Depth and Normal buffers are used by the post-processing shaders to modify the output. The Color buffer gets its data from the shaders used in the path tracing step. The Depth and Normal buffers are generated based on the first hit of each ray, and therefore reflections and refractions are not taken into account. Buffers can be modified by post-processing shaders, and even new buffers can be created by post-processing shaders if needed. Color Buffer This buffer contains the color of every pixel in the scene. As a whole, it forms the image we've been drawing in previous tutorials. Depth Buffer This buffer contains the depth of every pixel in the scene. The depth is the distance from the camera to the point where the ray hit the scene. Depth is measured as a percentage of the distance from the camera to the far plane, between 0 and 1. Important Information in the depth buffer is stored as floating point values, not Color3. To render a pixel in the depth buffer as a color like in the above image, you must first convert the depth value to a color. local PixelDepth = myRayTracer . Buffers . Depth [ x ][ y ] local Color = Color3 . new ( PixelDepth , PixelDepth , PixelDepth ) Normal Buffer This buffer contains the normal of every pixel in the scene. The normal is the direction of the surface at the point where the ray hit the scene. The vectors are represented as Color3 values, where the r, g and b values are the x, y and z components of the normal vector respectively. Important The color of a normal vector is calculated as follows: local normalColor = Color3 . new (( normal . X + 1 ) / 2 , ( normal . Y + 1 ) / 2 , ( normal . Z + 1 ) / 2 ) If a normal vector is a zero vector, its color is grey.","title":"Buffers"},{"location":"getting-started/buffers/#buffers","text":"The Color, Depth and Normal buffers are used by the post-processing shaders to modify the output. The Color buffer gets its data from the shaders used in the path tracing step. The Depth and Normal buffers are generated based on the first hit of each ray, and therefore reflections and refractions are not taken into account. Buffers can be modified by post-processing shaders, and even new buffers can be created by post-processing shaders if needed.","title":"Buffers"},{"location":"getting-started/buffers/#color-buffer","text":"This buffer contains the color of every pixel in the scene. As a whole, it forms the image we've been drawing in previous tutorials.","title":"Color Buffer"},{"location":"getting-started/buffers/#depth-buffer","text":"This buffer contains the depth of every pixel in the scene. The depth is the distance from the camera to the point where the ray hit the scene. Depth is measured as a percentage of the distance from the camera to the far plane, between 0 and 1. Important Information in the depth buffer is stored as floating point values, not Color3. To render a pixel in the depth buffer as a color like in the above image, you must first convert the depth value to a color. local PixelDepth = myRayTracer . Buffers . Depth [ x ][ y ] local Color = Color3 . new ( PixelDepth , PixelDepth , PixelDepth )","title":"Depth Buffer"},{"location":"getting-started/buffers/#normal-buffer","text":"This buffer contains the normal of every pixel in the scene. The normal is the direction of the surface at the point where the ray hit the scene. The vectors are represented as Color3 values, where the r, g and b values are the x, y and z components of the normal vector respectively. Important The color of a normal vector is calculated as follows: local normalColor = Color3 . new (( normal . X + 1 ) / 2 , ( normal . Y + 1 ) / 2 , ( normal . Z + 1 ) / 2 ) If a normal vector is a zero vector, its color is grey.","title":"Normal Buffer"},{"location":"getting-started/first-render/","text":"Creating your first render To get started, create a new RayTracingCamera to determine the camera position and orientation, as well as field of view and resolution. -- We'll assume 'package' is the location of the Luau Ray Tracer package. -- This will also be assumed in further examples. local RayTracingCamera = require ( package . classes . RayTracingCamera ) -- We'll use a resolution of 100x100 to avoid having to wait too long for the render to complete. local resolution = Vector2 ( 100 , 100 ) local fieldOfView = math.rad ( 70 ) -- Field of view is measured in radians. local farPlane = 100 -- How far the camera can see. -- We'll place the camera 5 studs above the world origin. -- Because we're not defining a direction, the camera will be looking down the -Z axis. local CFrame = CFrame . new ( Vector3 . new ( 0 , 5 , 0 )) -- Create the camera. local myCamera = RayTracingCamera . new ( resolution , fieldOfView , farPlane , CFrame ) Now we have the camera. However, the camera is not the one doing the rendering. It only tells the RayTracer where to look and which direction each pixel should be cast. Let's create a RayTracer to do the rendering. -- We'll require the RayTracer class at the top of the script. local RayTracer = require ( package . classes . RayTracer ) -- We won't be defining shaders just yet, so we don't need to pass any parameters except the camera. -- Make sure you do this after you've created the camera. local myRayTracer = RayTracer . new ( myCamera ) Now we have both a camera and a RayTracer. Technically this is all we need to do to render a scene. Let's try it out by adding the following line to the end of our script: local image = myRayTracer : Render () Full script so far 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 local RayTracingCamera = require ( package . classes . RayTracingCamera ) local RayTracer = require ( package . classes . RayTracer ) -- We'll use a resolution of 100x100 to avoid having to wait too long for the render to complete. local resolution = Vector2 ( 100 , 100 ) local fieldOfView = math.rad ( 70 ) -- Field of view is measured in radians. local farPlane = 100 -- How far the camera can see. -- We'll place the camera 5 studs above the world origin. -- Because we're not defining a direction, the camera will be looking down the -Z axis. local CFrame = CFrame . new ( Vector3 . new ( 0 , 5 , 0 )) -- Create the camera. local myCamera = RayTracingCamera . new ( resolution , fieldOfView , farPlane , CFrame ) -- We won't be defining shaders just yet, so we don't need to pass any parameters except the camera. local myRayTracer = RayTracer . new ( myCamera ) local image = myRayTracer : Render () You now have your first ray traced render! However, you still can't see an image yet. This is because the RayTracer does not display the image; instead, it returns it as a table. Let's create a function to display the image using parts. function showImage ( image ) for x = 1 , # image do for y = 1 , # image [ x ] do local pixel = Instance . new ( \"Part\" ) pixel . Size = Vector3 . new ( 1 , 1 , 0 ) pixel . Position = Vector3 . new ( x , resolution . Y - y , - resolution . X ) - Vector3 . new ( resolution . X / 2 , resolution . Y / 2 , 0 ) pixel . Anchored = true pixel . CanCollide = false pixel . CanTouch = false pixel . CanQuery = false pixel . CastShadow = false pixel . Locked = true pixel . Color = image [ x ][ y ] pixel . Material = Enum . Material . SmoothPlastic pixel . Parent = workspace end end end And now we can call the function to display the image. showImage ( image ) Full script so far 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 local RayTracingCamera = require ( package . classes . RayTracingCamera ) local RayTracer = require ( package . classes . RayTracer ) -- We'll use a resolution of 100x100 to avoid having to wait too long for the render to complete. local resolution = Vector2 . new ( 100 , 100 ) local fieldOfView = math.rad ( 70 ) -- Field of view is measured in radians. local farPlane = 100 -- How far the camera can see. -- We'll place the camera 5 studs above the world origin. -- Because we're not defining a direction, the camera will be looking down the -Z axis. local CFrame = CFrame . new ( Vector3 . new ( 0 , 5 , 0 )) -- Create the camera. local myCamera = RayTracingCamera . new ( resolution , fieldOfView , farPlane , CFrame ) -- We won't be defining shaders just yet, so we don't need to pass any parameters except the camera. local myRayTracer = RayTracer . new ( myCamera ) local image = myRayTracer : Render () function showImage ( image ) for x = 1 , # image do for y = 1 , # image [ x ] do local pixel = Instance . new ( \"Part\" ) pixel . Size = Vector3 . new ( 1 , 1 , 0 ) pixel . Position = Vector3 . new ( x , resolution . Y - y , - resolution . X ) - Vector3 . new ( resolution . X / 2 , resolution . Y / 2 , 0 ) pixel . Anchored = true pixel . CanCollide = false pixel . CanTouch = false pixel . CanQuery = false pixel . CastShadow = false pixel . Locked = true pixel . Color = image [ x ][ y ] pixel . Material = Enum . Material . SmoothPlastic pixel . Parent = workspace end end end showImage ( image ) You can see a beautiful magenta square. But why is it magenta? Magenta is the default color for a pixel that does not have any shading applied. This makes it easy to see which pixels are not being shaded, which is useful for debugging. But it's proably not the kind of image you wanted to see. In order to actually see something, we need to define shaders for the RayTracer to use, so it knows what to do with each pixel. We'll start creating shaders in the next section.","title":"Creating your first render"},{"location":"getting-started/first-render/#creating-your-first-render","text":"To get started, create a new RayTracingCamera to determine the camera position and orientation, as well as field of view and resolution. -- We'll assume 'package' is the location of the Luau Ray Tracer package. -- This will also be assumed in further examples. local RayTracingCamera = require ( package . classes . RayTracingCamera ) -- We'll use a resolution of 100x100 to avoid having to wait too long for the render to complete. local resolution = Vector2 ( 100 , 100 ) local fieldOfView = math.rad ( 70 ) -- Field of view is measured in radians. local farPlane = 100 -- How far the camera can see. -- We'll place the camera 5 studs above the world origin. -- Because we're not defining a direction, the camera will be looking down the -Z axis. local CFrame = CFrame . new ( Vector3 . new ( 0 , 5 , 0 )) -- Create the camera. local myCamera = RayTracingCamera . new ( resolution , fieldOfView , farPlane , CFrame ) Now we have the camera. However, the camera is not the one doing the rendering. It only tells the RayTracer where to look and which direction each pixel should be cast. Let's create a RayTracer to do the rendering. -- We'll require the RayTracer class at the top of the script. local RayTracer = require ( package . classes . RayTracer ) -- We won't be defining shaders just yet, so we don't need to pass any parameters except the camera. -- Make sure you do this after you've created the camera. local myRayTracer = RayTracer . new ( myCamera ) Now we have both a camera and a RayTracer. Technically this is all we need to do to render a scene. Let's try it out by adding the following line to the end of our script: local image = myRayTracer : Render () Full script so far 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 local RayTracingCamera = require ( package . classes . RayTracingCamera ) local RayTracer = require ( package . classes . RayTracer ) -- We'll use a resolution of 100x100 to avoid having to wait too long for the render to complete. local resolution = Vector2 ( 100 , 100 ) local fieldOfView = math.rad ( 70 ) -- Field of view is measured in radians. local farPlane = 100 -- How far the camera can see. -- We'll place the camera 5 studs above the world origin. -- Because we're not defining a direction, the camera will be looking down the -Z axis. local CFrame = CFrame . new ( Vector3 . new ( 0 , 5 , 0 )) -- Create the camera. local myCamera = RayTracingCamera . new ( resolution , fieldOfView , farPlane , CFrame ) -- We won't be defining shaders just yet, so we don't need to pass any parameters except the camera. local myRayTracer = RayTracer . new ( myCamera ) local image = myRayTracer : Render () You now have your first ray traced render! However, you still can't see an image yet. This is because the RayTracer does not display the image; instead, it returns it as a table. Let's create a function to display the image using parts. function showImage ( image ) for x = 1 , # image do for y = 1 , # image [ x ] do local pixel = Instance . new ( \"Part\" ) pixel . Size = Vector3 . new ( 1 , 1 , 0 ) pixel . Position = Vector3 . new ( x , resolution . Y - y , - resolution . X ) - Vector3 . new ( resolution . X / 2 , resolution . Y / 2 , 0 ) pixel . Anchored = true pixel . CanCollide = false pixel . CanTouch = false pixel . CanQuery = false pixel . CastShadow = false pixel . Locked = true pixel . Color = image [ x ][ y ] pixel . Material = Enum . Material . SmoothPlastic pixel . Parent = workspace end end end And now we can call the function to display the image. showImage ( image ) Full script so far 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 local RayTracingCamera = require ( package . classes . RayTracingCamera ) local RayTracer = require ( package . classes . RayTracer ) -- We'll use a resolution of 100x100 to avoid having to wait too long for the render to complete. local resolution = Vector2 . new ( 100 , 100 ) local fieldOfView = math.rad ( 70 ) -- Field of view is measured in radians. local farPlane = 100 -- How far the camera can see. -- We'll place the camera 5 studs above the world origin. -- Because we're not defining a direction, the camera will be looking down the -Z axis. local CFrame = CFrame . new ( Vector3 . new ( 0 , 5 , 0 )) -- Create the camera. local myCamera = RayTracingCamera . new ( resolution , fieldOfView , farPlane , CFrame ) -- We won't be defining shaders just yet, so we don't need to pass any parameters except the camera. local myRayTracer = RayTracer . new ( myCamera ) local image = myRayTracer : Render () function showImage ( image ) for x = 1 , # image do for y = 1 , # image [ x ] do local pixel = Instance . new ( \"Part\" ) pixel . Size = Vector3 . new ( 1 , 1 , 0 ) pixel . Position = Vector3 . new ( x , resolution . Y - y , - resolution . X ) - Vector3 . new ( resolution . X / 2 , resolution . Y / 2 , 0 ) pixel . Anchored = true pixel . CanCollide = false pixel . CanTouch = false pixel . CanQuery = false pixel . CastShadow = false pixel . Locked = true pixel . Color = image [ x ][ y ] pixel . Material = Enum . Material . SmoothPlastic pixel . Parent = workspace end end end showImage ( image ) You can see a beautiful magenta square. But why is it magenta? Magenta is the default color for a pixel that does not have any shading applied. This makes it easy to see which pixels are not being shaded, which is useful for debugging. But it's proably not the kind of image you wanted to see. In order to actually see something, we need to define shaders for the RayTracer to use, so it knows what to do with each pixel. We'll start creating shaders in the next section.","title":"Creating your first render"},{"location":"getting-started/first-shader/","text":"Creating your first shader Now that we have a camera and a RayTracer, we're ready to start defining shaders. If you skipped the previous section, here is the code we've written so far: Full script so far 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 local RayTracingCamera = require ( package . classes . RayTracingCamera ) local RayTracer = require ( package . classes . RayTracer ) -- We'll use a resolution of 100x100 to avoid having to wait too long for the render to complete. local resolution = Vector2 . new ( 100 , 100 ) local fieldOfView = math.rad ( 70 ) -- Field of view is measured in radians. local farPlane = 100 -- How far the camera can see. -- We'll place the camera 5 studs above the world origin. -- Because we're not defining a direction, the camera will be looking down the -Z axis. local CFrame = CFrame . new ( Vector3 . new ( 0 , 5 , 0 )) -- Create the camera. local myCamera = RayTracingCamera . new ( resolution , fieldOfView , farPlane , CFrame ) -- We won't be defining shaders just yet, so we don't need to pass any parameters except the camera. local myRayTracer = RayTracer . new ( myCamera ) local image = myRayTracer : Render () function showImage ( image ) for x = 1 , # image do for y = 1 , # image [ x ] do local pixel = Instance . new ( \"Part\" ) pixel . Size = Vector3 . new ( 1 , 1 , 0 ) pixel . Position = Vector3 . new ( x , y , - resolution . X ) - Vector3 . new ( resolution . X / 2 , resolution . Y / 2 , 0 ) pixel . Anchored = true pixel . CanCollide = false pixel . CanTouch = false pixel . CanQuery = false pixel . CastShadow = true pixel . Locked = true pixel . Color = image [ x ][ y ] pixel . Material = Enum . Material . SmoothPlastic pixel . Parent = workspace end end end showImage ( image ) What is a shader? If you already know what a shader is, you can skip to the next section. Otherwise, here is a quick explanation. A shader is a set of instructions that define how a pixel should be colored based on several factors such as the position of the camera and the position of the object being rendered. Normally shaders run on the GPU, but since this is Roblox, we'll have to settle for running them on the CPU. This is not great for performance, as even a 640x480 image has a lot of pixels that need to be calculated, and a CPU only has a handful of cores unlike a GPU, which can have thousands of cores calculating the shaders for several pixels at a time. How do shaders work with the RayTracer? Luau Ray Tracer is a library that allows you to define shaders in Lua. Luau shaders are defined as objects that inherit from the Shader class. Each shader has a function which determines how a pixel should be colored, and if more rays should be created to simulate phenomena like reflection and refraction. When a TracedRay terminates for any reason (i.e. it hits an object or the far plane), the shader is called to determine the color of the pixel. If the shader returns a color, that color is used to color the pixel. If the shader returns nil , the pixel will keep its current color. Example Shader Here's an example shader that makes every Part whose name is 'Mirror' to reflect the ray. -- ModuleScript local Shader = require ( script . Parent . Parent . classes . Shader ) local MirrorShader = Shader . new () MirrorShader . Function = function ( Ray , Hit , ...) -- If the ray didn't hit anything, skip this shader. if not Hit then return end -- Only apply the shader to objects whose name is 'Mirror'. if Hit . Instance . Name == 'Mirror' then local Normal = Hit . Normal -- Create a reflection ray and return the color of the reflected ray. return Shader : Reflect ( Ray , Hit , Normal ). Color end end return MirrorShader This is still a very simple shader. More advanced shaders can be created with more complex logic. Creating a shader Let's create a shader that displays the color of an object if a ray hits it. We'll define the shader in a separate ModuleScript. For simplicity, we'll create a new folder called shaders in the package folder. We'll then create a ModuleScript called TestShader in the shaders folder. -- ModuleScript -- We'll begin by including the Shader class. -- Since the ModuleScript is in package.Shaders, we can use a relative path to the Shader class. local Shader = require ( script . Parent . Parent . classes . Shader ) -- Create a new shader. local TestShader = Shader . new () -- Define the function of the shader. TestShader . Function = function ( Ray , Hit , ...) -- If the ray didn't hit anything, skip this shader. if not Hit then return end -- Return the color of the object that was hit. return Hit . Instance . Color end -- Finally return the shader so we can use it. return TestShader Now we'll also need to require the shader in our main script. We'll do this at the top of our script. local TestShader = require ( package . shaders . TestShader ) Next, let's apply the shader to our ray tracer. We'll have to replace the current Ray Tracer definition with our new one. local myRayTracer = RayTracer . new ( myCamera , 1 , { TestShader }) Note that we're passing 3 arguments to the RayTracer now. The second argument is the maximum number of bounces that the ray can make before it's terminated. The third argument is an array of shaders to apply to the ray. In this case, we only have one shader, so we'll pass an array of length 1. Because our shader does not have reflections or refractions, 1 is enough for the maximum number of bounces. Full script so far 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 local RayTracingCamera = require ( package . classes . RayTracingCamera ) local RayTracer = require ( package . classes . RayTracer ) local TestShader = require ( package . shaders . TestShader ) -- We'll use a resolution of 100x100 to avoid having to wait too long for the render to complete. local resolution = Vector2 . new ( 100 , 100 ) local fieldOfView = math.rad ( 70 ) -- Field of view is measured in radians. local farPlane = 100 -- How far the camera can see. -- We'll place the camera 5 studs above the world origin. -- Because we're not defining a direction, the camera will be looking down the -Z axis. local CFrame = CFrame . new ( Vector3 . new ( 0 , 5 , 0 )) -- Create the camera. local myCamera = RayTracingCamera . new ( resolution , fieldOfView , farPlane , CFrame ) -- We won't be defining shaders just yet, so we don't need to pass any parameters except the camera. local myRayTracer = RayTracer . new ( myCamera , 1 , { TestShader }) local image = myRayTracer : Render () function showImage ( image ) for x = 1 , # image do for y = 1 , # image [ x ] do local pixel = Instance . new ( \"Part\" ) pixel . Size = Vector3 . new ( 1 , 1 , 0 ) pixel . Position = Vector3 . new ( x , resolution . Y - y , - resolution . X ) - Vector3 . new ( resolution . X / 2 , resolution . Y / 2 , 0 ) pixel . Anchored = true pixel . CanCollide = false pixel . CanTouch = false pixel . CanQuery = false pixel . CastShadow = false pixel . Locked = true pixel . Color = image [ x ][ y ] pixel . Material = Enum . Material . SmoothPlastic pixel . Parent = workspace end end end showImage ( image ) Let's see what our image looks like. It would seem that the shader is working as expected. If we put a green sphere in the scene, the sphere should be green in the final render as well. Tip Set the parts in your test scene to invisible so they don't block your view. Because we haven't defined a transparency shader, parts will be rendered as a solid color regardless of their transparency property. There is one problem with this shader. If a ray doesn't hit anything, it will keep its current color. Because we haven't defined a shader for rays that terminate without hitting anything, the sky is displayed as magenta. We'll deal with this in the next section.","title":"Creating your first shader"},{"location":"getting-started/first-shader/#creating-your-first-shader","text":"Now that we have a camera and a RayTracer, we're ready to start defining shaders. If you skipped the previous section, here is the code we've written so far: Full script so far 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 local RayTracingCamera = require ( package . classes . RayTracingCamera ) local RayTracer = require ( package . classes . RayTracer ) -- We'll use a resolution of 100x100 to avoid having to wait too long for the render to complete. local resolution = Vector2 . new ( 100 , 100 ) local fieldOfView = math.rad ( 70 ) -- Field of view is measured in radians. local farPlane = 100 -- How far the camera can see. -- We'll place the camera 5 studs above the world origin. -- Because we're not defining a direction, the camera will be looking down the -Z axis. local CFrame = CFrame . new ( Vector3 . new ( 0 , 5 , 0 )) -- Create the camera. local myCamera = RayTracingCamera . new ( resolution , fieldOfView , farPlane , CFrame ) -- We won't be defining shaders just yet, so we don't need to pass any parameters except the camera. local myRayTracer = RayTracer . new ( myCamera ) local image = myRayTracer : Render () function showImage ( image ) for x = 1 , # image do for y = 1 , # image [ x ] do local pixel = Instance . new ( \"Part\" ) pixel . Size = Vector3 . new ( 1 , 1 , 0 ) pixel . Position = Vector3 . new ( x , y , - resolution . X ) - Vector3 . new ( resolution . X / 2 , resolution . Y / 2 , 0 ) pixel . Anchored = true pixel . CanCollide = false pixel . CanTouch = false pixel . CanQuery = false pixel . CastShadow = true pixel . Locked = true pixel . Color = image [ x ][ y ] pixel . Material = Enum . Material . SmoothPlastic pixel . Parent = workspace end end end showImage ( image )","title":"Creating your first shader"},{"location":"getting-started/first-shader/#what-is-a-shader","text":"If you already know what a shader is, you can skip to the next section. Otherwise, here is a quick explanation. A shader is a set of instructions that define how a pixel should be colored based on several factors such as the position of the camera and the position of the object being rendered. Normally shaders run on the GPU, but since this is Roblox, we'll have to settle for running them on the CPU. This is not great for performance, as even a 640x480 image has a lot of pixels that need to be calculated, and a CPU only has a handful of cores unlike a GPU, which can have thousands of cores calculating the shaders for several pixels at a time.","title":"What is a shader?"},{"location":"getting-started/first-shader/#how-do-shaders-work-with-the-raytracer","text":"Luau Ray Tracer is a library that allows you to define shaders in Lua. Luau shaders are defined as objects that inherit from the Shader class. Each shader has a function which determines how a pixel should be colored, and if more rays should be created to simulate phenomena like reflection and refraction. When a TracedRay terminates for any reason (i.e. it hits an object or the far plane), the shader is called to determine the color of the pixel. If the shader returns a color, that color is used to color the pixel. If the shader returns nil , the pixel will keep its current color. Example Shader Here's an example shader that makes every Part whose name is 'Mirror' to reflect the ray. -- ModuleScript local Shader = require ( script . Parent . Parent . classes . Shader ) local MirrorShader = Shader . new () MirrorShader . Function = function ( Ray , Hit , ...) -- If the ray didn't hit anything, skip this shader. if not Hit then return end -- Only apply the shader to objects whose name is 'Mirror'. if Hit . Instance . Name == 'Mirror' then local Normal = Hit . Normal -- Create a reflection ray and return the color of the reflected ray. return Shader : Reflect ( Ray , Hit , Normal ). Color end end return MirrorShader This is still a very simple shader. More advanced shaders can be created with more complex logic.","title":"How do shaders work with the RayTracer?"},{"location":"getting-started/first-shader/#creating-a-shader","text":"Let's create a shader that displays the color of an object if a ray hits it. We'll define the shader in a separate ModuleScript. For simplicity, we'll create a new folder called shaders in the package folder. We'll then create a ModuleScript called TestShader in the shaders folder. -- ModuleScript -- We'll begin by including the Shader class. -- Since the ModuleScript is in package.Shaders, we can use a relative path to the Shader class. local Shader = require ( script . Parent . Parent . classes . Shader ) -- Create a new shader. local TestShader = Shader . new () -- Define the function of the shader. TestShader . Function = function ( Ray , Hit , ...) -- If the ray didn't hit anything, skip this shader. if not Hit then return end -- Return the color of the object that was hit. return Hit . Instance . Color end -- Finally return the shader so we can use it. return TestShader Now we'll also need to require the shader in our main script. We'll do this at the top of our script. local TestShader = require ( package . shaders . TestShader ) Next, let's apply the shader to our ray tracer. We'll have to replace the current Ray Tracer definition with our new one. local myRayTracer = RayTracer . new ( myCamera , 1 , { TestShader }) Note that we're passing 3 arguments to the RayTracer now. The second argument is the maximum number of bounces that the ray can make before it's terminated. The third argument is an array of shaders to apply to the ray. In this case, we only have one shader, so we'll pass an array of length 1. Because our shader does not have reflections or refractions, 1 is enough for the maximum number of bounces. Full script so far 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 local RayTracingCamera = require ( package . classes . RayTracingCamera ) local RayTracer = require ( package . classes . RayTracer ) local TestShader = require ( package . shaders . TestShader ) -- We'll use a resolution of 100x100 to avoid having to wait too long for the render to complete. local resolution = Vector2 . new ( 100 , 100 ) local fieldOfView = math.rad ( 70 ) -- Field of view is measured in radians. local farPlane = 100 -- How far the camera can see. -- We'll place the camera 5 studs above the world origin. -- Because we're not defining a direction, the camera will be looking down the -Z axis. local CFrame = CFrame . new ( Vector3 . new ( 0 , 5 , 0 )) -- Create the camera. local myCamera = RayTracingCamera . new ( resolution , fieldOfView , farPlane , CFrame ) -- We won't be defining shaders just yet, so we don't need to pass any parameters except the camera. local myRayTracer = RayTracer . new ( myCamera , 1 , { TestShader }) local image = myRayTracer : Render () function showImage ( image ) for x = 1 , # image do for y = 1 , # image [ x ] do local pixel = Instance . new ( \"Part\" ) pixel . Size = Vector3 . new ( 1 , 1 , 0 ) pixel . Position = Vector3 . new ( x , resolution . Y - y , - resolution . X ) - Vector3 . new ( resolution . X / 2 , resolution . Y / 2 , 0 ) pixel . Anchored = true pixel . CanCollide = false pixel . CanTouch = false pixel . CanQuery = false pixel . CastShadow = false pixel . Locked = true pixel . Color = image [ x ][ y ] pixel . Material = Enum . Material . SmoothPlastic pixel . Parent = workspace end end end showImage ( image ) Let's see what our image looks like. It would seem that the shader is working as expected. If we put a green sphere in the scene, the sphere should be green in the final render as well. Tip Set the parts in your test scene to invisible so they don't block your view. Because we haven't defined a transparency shader, parts will be rendered as a solid color regardless of their transparency property. There is one problem with this shader. If a ray doesn't hit anything, it will keep its current color. Because we haven't defined a shader for rays that terminate without hitting anything, the sky is displayed as magenta. We'll deal with this in the next section.","title":"Creating a shader"},{"location":"getting-started/installation/","text":"Installation Installing Luau Ray Tracer is no different from installing any other Lua module: Insert Luau Ray Tracer to your project and place it to the service of your choice. Require the RayTracingCamera and RayTracer classes to get started. local package -- Insert the location of the Luau Ray Tracer package here. local RayTracingCamera = require ( package . RayTracingCamera ) local RayTracer = require ( package . RayTracer ) You're ready to go! Refer to the API reference and other documentation for more information.","title":"Installation"},{"location":"getting-started/installation/#installation","text":"Installing Luau Ray Tracer is no different from installing any other Lua module: Insert Luau Ray Tracer to your project and place it to the service of your choice. Require the RayTracingCamera and RayTracer classes to get started. local package -- Insert the location of the Luau Ray Tracer package here. local RayTracingCamera = require ( package . RayTracingCamera ) local RayTracer = require ( package . RayTracer ) You're ready to go! Refer to the API reference and other documentation for more information.","title":"Installation"},{"location":"getting-started/post-processing/","text":"Post-processing Post-processing is the act of transforming the initially generated output into a final output. In this case this means modifying the Color, Depth and Normal buffers as needed after the path tracing step has completed. Post-processing is not required for the ray tracer to work, but can be useful for creating interesting effects. Important The post-processing step only runs after the path tracing step has completed. This means that individual path data is not available to post-processing shaders. Unlike path shaders, post-processing shaders have access to all pixels in every buffer at once. Post-processing shaders Post-processing shaders are shaders that are run after the path tracing step has completed. They are run on every pixel in the scene, and can modify the Color, Depth and Normal buffers. Creating a post-processing shader Let's create a shader that detects edges in the image based the shapes of the objects in the scene. We will be using depth-based edge detection, which isn't the most accurate method, but is simple to implement. It is recommended that you create a new folder in the Luau Ray Tracer package called postprocessing and put your post-processing shaders in there. For the purposes of this tutorial, we'll be assuming you do that. Start by creating a new ModuleScript called EdgeDetection in the postprocessing folder. -- ModuleScript local PostProcessingShader = require ( script . Parent . Parent . classes . PostProcessingShader ) local EdgeDetection = PostProcessingShader . new () How does depth-based edge detection work? Depth-based edge detection works by comparing the depth of each pixel to the depths of the adjacent pixels. If the difference between the depths is greater than a threshold, the pixel is considered an edge. Let's define the function of the shader. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 -- Depth difference threshold to detect edges. -- If the depth difference between a pixel and its adjacent pixel is greater than this threshold, the pixel is considered an edge. local edgeThreshold = 0.2 EdgeDetection . Function = function ( Raytracer , ...) -- Loop through every pixel in the image. for x = 1 , Raytracer . Camera . Resolution . X do for y = 1 , Raytracer . Camera . Resolution . Y do -- Get the depth of the current pixel. local CurrentDepth = Raytracer . Buffers . Depth [ x ][ y ] -- Collect all the adjacent pixels. -- The first argument is the pixel's position, the second is the size of the ray traced viewport. -- The third argument is the radius of the area to search for adjacent pixels. local AdjacentPixels = EdgeDetection : GetAdjacentPixels ( Vector2 . new ( x , y ), Raytracer . Camera . Resolution , 1 ) local AdjacentDepth = {} -- Get the depth value for each pixel position from the depth buffer for _ , pixel in AdjacentPixels do table.insert ( AdjacentDepth , Raytracer . Buffers . Depth [ pixel . X ][ pixel . Y ]) end -- Sort the depths. We'll use this to find the minimum and maximum depths. table.sort ( AdjacentDepth ) -- Get the difference between the depths. local DepthDifference = math.abs ( AdjacentDepth [ 1 ] - AdjacentDepth [ # AdjacentDepth ]) -- If the difference is greater than a threshold, the pixel is an edge. if DepthDifference > edgeThreshold then -- Edges will be highlighted in red in the image. -- Note that SetPixel sets the color of the pixel, not the depth. Raytracer : SetPixel ( x , y , Color3 . new ( 1 , 0 , 0 )) end end end -- Since we don't need to generate any more buffers, we can return the Ray Tracer's buffers in their current state. -- This has the same result as returning nil. return Raytracer . Buffers end return EdgeDetection The full EdgeDetection shader 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 -- ModuleScript local PostProcessingShader = require ( script . Parent . Parent . classes . PostProcessingShader ) local EdgeDetection = PostProcessingShader . new () -- Depth difference threshold to detect edges. -- If the depth difference between a pixel and its adjacent pixel is greater than this threshold, the pixel is considered an edge. local edgeThreshold = 0.2 EdgeDetection . Function = function ( Raytracer , ...) -- Loop through every pixel in the image. for x = 1 , Raytracer . Camera . Resolution . X do for y = 1 , Raytracer . Camera . Resolution . Y do -- Get the depth of the current pixel. local CurrentDepth = Raytracer . Buffers . Depth [ x ][ y ] -- Collect all the adjacent pixels. -- The first argument is the pixel's position, the second is the size of the ray traced viewport. -- The third argument is the radius of the area to search for adjacent pixels. local AdjacentPixels = EdgeDetection : GetAdjacentPixels ( Vector2 . new ( x , y ), Raytracer . Camera . Resolution , 1 ) local AdjacentDepth = {} -- Get the depth value for each pixel position from the depth buffer for _ , pixel in AdjacentPixels do table.insert ( AdjacentDepth , Raytracer . Buffers . Depth [ pixel . X ][ pixel . Y ]) end -- Sort the depths. We'll use this to find the minimum and maximum depths. table.sort ( AdjacentDepth ) -- Get the difference between the depths. local DepthDifference = math.abs ( AdjacentDepth [ 1 ] - AdjacentDepth [ # AdjacentDepth ]) -- If the difference is greater than a threshold, the pixel is an edge. if DepthDifference > edgeThreshold then -- Edges will be highlighted in red in the image. -- Note that SetPixel sets the color of the pixel, not the depth. Raytracer : SetPixel ( x , y , Color3 . new ( 1 , 0 , 0 )) end end end -- Since we don't need to generate any more buffers, we can return the Ray Tracer's buffers in their current state. -- This has the same result as returning nil. return Raytracer . Buffers end return EdgeDetection Important Note that the Function property of the shader is a function that takes the Ray Tracer as its first argument. This is passed automatically when calling RayTracer:PostProcess() . ... is the rest of the arguments passed to the shader via the RayTracer:PostProcess method. Important The shader function is responsible for selecting the appropriate pixels to modify. If you want to modify every pixel in the image, you can do so by looping through every pixel in the image, as seen in the code above. Note The post-processing shaders are expected to return nothing or the Ray Tracer's buffers to be used for the next post-processing shader. If the shader returns nil , the Ray Tracer will continue to use its current buffers. Returning the buffers can be useful if you want to pass additional information to the next post-processing shader, as you can return more buffers than what the Ray Tracer has by default. Now let's add the Edge Detection shader to our main script. local EdgeDetection = require ( package . postprocessing . EdgeDetection ) And replace the previous RayTracer with the following: local myRayTracer = RayTracer . new ( myCamera , 1 , { SkyShader , TestShader }, { EdgeDetection }) Just like the other shaders, post-processing shaders are passed to the Ray Tracer in a table and executed in order. If we try rendering our scene again, we'll notice that nothing has changed. This is because post-processing shaders are not automatically executed when rendering a scene. To execute the post-processing shaders, we can call the RayTracer:PostProcess() method after the initial render: local image = myRayTracer : Render () myRayTracer : PostProcess () The full script so far 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 local RayTracingCamera = require ( package . classes . RayTracingCamera ) local RayTracer = require ( package . classes . RayTracer ) local TestShader = require ( package . shaders . TestShader ) local SkyShader = require ( package . shaders . SkyShader ) local EdgeDetection = require ( package . postprocessing . EdgeDetection ) -- We'll use a resolution of 100x100 to avoid having to wait too long for the render to complete. local resolution = Vector2 . new ( 100 , 100 ) local fieldOfView = math.rad ( 70 ) -- Field of view is measured in radians. local farPlane = 100 -- How far the camera can see. -- We'll place the camera 5 studs above the world origin. -- Because we're not defining a direction, the camera will be looking down the -Z axis. local CFrame = CFrame . new ( Vector3 . new ( 0 , 5 , 0 )) -- Create the camera. local myCamera = RayTracingCamera . new ( resolution , fieldOfView , farPlane , CFrame ) -- We won't be defining shaders just yet, so we don't need to pass any parameters except the camera. local myRayTracer = RayTracer . new ( myCamera , 1 , { SkyShader , TestShader }, { EdgeDetection }) local image = myRayTracer : Render () myRayTracer : PostProcess () function showImage ( image ) for x = 1 , # image do for y = 1 , # image [ x ] do local pixel = Instance . new ( \"Part\" ) pixel . Size = Vector3 . new ( 1 , 1 , 0 ) pixel . Position = Vector3 . new ( x , resolution . Y - y , - resolution . X ) - Vector3 . new ( resolution . X / 2 , resolution . Y / 2 , 0 ) pixel . Anchored = true pixel . CanCollide = false pixel . CanTouch = false pixel . CanQuery = false pixel . CastShadow = false pixel . Locked = true pixel . Color = image [ x ][ y ] pixel . Material = Enum . Material . SmoothPlastic pixel . Parent = workspace end end end showImage ( image ) Now let's try rendering our scene again. That looks pretty good! Let's try adding some more parts to the scene. Looks like the white block's edges are not detected. This is because in this particular example it's located close to the camera's far plane, resulting in the depth difference between the block and the camera to be too small for our shader to detect. In our shader we set 0.2 as the threshold, so an edge's minimum depth difference is 20% of the camera's far plane distance. In our main script we set the far plane to 100 studs, so the minimum depth difference is 0.2 * 100 = 20. Therefore, if the object is more than 80 studs away from the camera, it won't be detected as an edge. Let's bring the block closer to the camera.","title":"Post-processing"},{"location":"getting-started/post-processing/#post-processing","text":"Post-processing is the act of transforming the initially generated output into a final output. In this case this means modifying the Color, Depth and Normal buffers as needed after the path tracing step has completed. Post-processing is not required for the ray tracer to work, but can be useful for creating interesting effects. Important The post-processing step only runs after the path tracing step has completed. This means that individual path data is not available to post-processing shaders. Unlike path shaders, post-processing shaders have access to all pixels in every buffer at once.","title":"Post-processing"},{"location":"getting-started/post-processing/#post-processing-shaders","text":"Post-processing shaders are shaders that are run after the path tracing step has completed. They are run on every pixel in the scene, and can modify the Color, Depth and Normal buffers.","title":"Post-processing shaders"},{"location":"getting-started/post-processing/#creating-a-post-processing-shader","text":"Let's create a shader that detects edges in the image based the shapes of the objects in the scene. We will be using depth-based edge detection, which isn't the most accurate method, but is simple to implement. It is recommended that you create a new folder in the Luau Ray Tracer package called postprocessing and put your post-processing shaders in there. For the purposes of this tutorial, we'll be assuming you do that. Start by creating a new ModuleScript called EdgeDetection in the postprocessing folder. -- ModuleScript local PostProcessingShader = require ( script . Parent . Parent . classes . PostProcessingShader ) local EdgeDetection = PostProcessingShader . new () How does depth-based edge detection work? Depth-based edge detection works by comparing the depth of each pixel to the depths of the adjacent pixels. If the difference between the depths is greater than a threshold, the pixel is considered an edge. Let's define the function of the shader. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 -- Depth difference threshold to detect edges. -- If the depth difference between a pixel and its adjacent pixel is greater than this threshold, the pixel is considered an edge. local edgeThreshold = 0.2 EdgeDetection . Function = function ( Raytracer , ...) -- Loop through every pixel in the image. for x = 1 , Raytracer . Camera . Resolution . X do for y = 1 , Raytracer . Camera . Resolution . Y do -- Get the depth of the current pixel. local CurrentDepth = Raytracer . Buffers . Depth [ x ][ y ] -- Collect all the adjacent pixels. -- The first argument is the pixel's position, the second is the size of the ray traced viewport. -- The third argument is the radius of the area to search for adjacent pixels. local AdjacentPixels = EdgeDetection : GetAdjacentPixels ( Vector2 . new ( x , y ), Raytracer . Camera . Resolution , 1 ) local AdjacentDepth = {} -- Get the depth value for each pixel position from the depth buffer for _ , pixel in AdjacentPixels do table.insert ( AdjacentDepth , Raytracer . Buffers . Depth [ pixel . X ][ pixel . Y ]) end -- Sort the depths. We'll use this to find the minimum and maximum depths. table.sort ( AdjacentDepth ) -- Get the difference between the depths. local DepthDifference = math.abs ( AdjacentDepth [ 1 ] - AdjacentDepth [ # AdjacentDepth ]) -- If the difference is greater than a threshold, the pixel is an edge. if DepthDifference > edgeThreshold then -- Edges will be highlighted in red in the image. -- Note that SetPixel sets the color of the pixel, not the depth. Raytracer : SetPixel ( x , y , Color3 . new ( 1 , 0 , 0 )) end end end -- Since we don't need to generate any more buffers, we can return the Ray Tracer's buffers in their current state. -- This has the same result as returning nil. return Raytracer . Buffers end return EdgeDetection The full EdgeDetection shader 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 -- ModuleScript local PostProcessingShader = require ( script . Parent . Parent . classes . PostProcessingShader ) local EdgeDetection = PostProcessingShader . new () -- Depth difference threshold to detect edges. -- If the depth difference between a pixel and its adjacent pixel is greater than this threshold, the pixel is considered an edge. local edgeThreshold = 0.2 EdgeDetection . Function = function ( Raytracer , ...) -- Loop through every pixel in the image. for x = 1 , Raytracer . Camera . Resolution . X do for y = 1 , Raytracer . Camera . Resolution . Y do -- Get the depth of the current pixel. local CurrentDepth = Raytracer . Buffers . Depth [ x ][ y ] -- Collect all the adjacent pixels. -- The first argument is the pixel's position, the second is the size of the ray traced viewport. -- The third argument is the radius of the area to search for adjacent pixels. local AdjacentPixels = EdgeDetection : GetAdjacentPixels ( Vector2 . new ( x , y ), Raytracer . Camera . Resolution , 1 ) local AdjacentDepth = {} -- Get the depth value for each pixel position from the depth buffer for _ , pixel in AdjacentPixels do table.insert ( AdjacentDepth , Raytracer . Buffers . Depth [ pixel . X ][ pixel . Y ]) end -- Sort the depths. We'll use this to find the minimum and maximum depths. table.sort ( AdjacentDepth ) -- Get the difference between the depths. local DepthDifference = math.abs ( AdjacentDepth [ 1 ] - AdjacentDepth [ # AdjacentDepth ]) -- If the difference is greater than a threshold, the pixel is an edge. if DepthDifference > edgeThreshold then -- Edges will be highlighted in red in the image. -- Note that SetPixel sets the color of the pixel, not the depth. Raytracer : SetPixel ( x , y , Color3 . new ( 1 , 0 , 0 )) end end end -- Since we don't need to generate any more buffers, we can return the Ray Tracer's buffers in their current state. -- This has the same result as returning nil. return Raytracer . Buffers end return EdgeDetection Important Note that the Function property of the shader is a function that takes the Ray Tracer as its first argument. This is passed automatically when calling RayTracer:PostProcess() . ... is the rest of the arguments passed to the shader via the RayTracer:PostProcess method. Important The shader function is responsible for selecting the appropriate pixels to modify. If you want to modify every pixel in the image, you can do so by looping through every pixel in the image, as seen in the code above. Note The post-processing shaders are expected to return nothing or the Ray Tracer's buffers to be used for the next post-processing shader. If the shader returns nil , the Ray Tracer will continue to use its current buffers. Returning the buffers can be useful if you want to pass additional information to the next post-processing shader, as you can return more buffers than what the Ray Tracer has by default. Now let's add the Edge Detection shader to our main script. local EdgeDetection = require ( package . postprocessing . EdgeDetection ) And replace the previous RayTracer with the following: local myRayTracer = RayTracer . new ( myCamera , 1 , { SkyShader , TestShader }, { EdgeDetection }) Just like the other shaders, post-processing shaders are passed to the Ray Tracer in a table and executed in order. If we try rendering our scene again, we'll notice that nothing has changed. This is because post-processing shaders are not automatically executed when rendering a scene. To execute the post-processing shaders, we can call the RayTracer:PostProcess() method after the initial render: local image = myRayTracer : Render () myRayTracer : PostProcess () The full script so far 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 local RayTracingCamera = require ( package . classes . RayTracingCamera ) local RayTracer = require ( package . classes . RayTracer ) local TestShader = require ( package . shaders . TestShader ) local SkyShader = require ( package . shaders . SkyShader ) local EdgeDetection = require ( package . postprocessing . EdgeDetection ) -- We'll use a resolution of 100x100 to avoid having to wait too long for the render to complete. local resolution = Vector2 . new ( 100 , 100 ) local fieldOfView = math.rad ( 70 ) -- Field of view is measured in radians. local farPlane = 100 -- How far the camera can see. -- We'll place the camera 5 studs above the world origin. -- Because we're not defining a direction, the camera will be looking down the -Z axis. local CFrame = CFrame . new ( Vector3 . new ( 0 , 5 , 0 )) -- Create the camera. local myCamera = RayTracingCamera . new ( resolution , fieldOfView , farPlane , CFrame ) -- We won't be defining shaders just yet, so we don't need to pass any parameters except the camera. local myRayTracer = RayTracer . new ( myCamera , 1 , { SkyShader , TestShader }, { EdgeDetection }) local image = myRayTracer : Render () myRayTracer : PostProcess () function showImage ( image ) for x = 1 , # image do for y = 1 , # image [ x ] do local pixel = Instance . new ( \"Part\" ) pixel . Size = Vector3 . new ( 1 , 1 , 0 ) pixel . Position = Vector3 . new ( x , resolution . Y - y , - resolution . X ) - Vector3 . new ( resolution . X / 2 , resolution . Y / 2 , 0 ) pixel . Anchored = true pixel . CanCollide = false pixel . CanTouch = false pixel . CanQuery = false pixel . CastShadow = false pixel . Locked = true pixel . Color = image [ x ][ y ] pixel . Material = Enum . Material . SmoothPlastic pixel . Parent = workspace end end end showImage ( image ) Now let's try rendering our scene again. That looks pretty good! Let's try adding some more parts to the scene. Looks like the white block's edges are not detected. This is because in this particular example it's located close to the camera's far plane, resulting in the depth difference between the block and the camera to be too small for our shader to detect. In our shader we set 0.2 as the threshold, so an edge's minimum depth difference is 20% of the camera's far plane distance. In our main script we set the far plane to 100 studs, so the minimum depth difference is 0.2 * 100 = 20. Therefore, if the object is more than 80 studs away from the camera, it won't be detected as an edge. Let's bring the block closer to the camera.","title":"Creating a post-processing shader"},{"location":"getting-started/sky-shaders/","text":"Sky shaders In the previous part we created a shader that displayed the color of an object if a ray hits it. If a ray didn't hit anything, no shader was applied, resulting in the sky appearing as magenta. Let's create a shader that is only applied if a ray doesn't hit anything. Just like before, we'll define the shader in a ModuleScript located in the shaders folder. -- ModuleScript local Shader = require ( script . Parent . Parent . classes . Shader ) local SkyShader = Shader . new () -- Define the function of the shader. SkyShader . Function = function ( Ray , Hit , ...) -- If the ray hit something, skip this shader. if Hit then return end -- Let's return a solid light blue color to represent the sky. return Color3 . new ( 0.5 , 0.5 , 1 ) end return SkyShader Now let's add the sky shader to our ray tracer. First we'll have to require the shader in our main script. local SkyShader = require ( package . shaders . SkyShader ) Just like we did with the first shader, we'll replace the current Ray Tracer definition with our new one. This time we'll include both the sky shader and the first shader. local myRayTracer = RayTracer . new ( myCamera , 1 , { SkyShader , TestShader }) Full script so far 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 local RayTracingCamera = require ( package . classes . RayTracingCamera ) local RayTracer = require ( package . classes . RayTracer ) local TestShader = require ( package . shaders . TestShader ) local SkyShader = require ( package . shaders . SkyShader ) -- We'll use a resolution of 100x100 to avoid having to wait too long for the render to complete. local resolution = Vector2 . new ( 100 , 100 ) local fieldOfView = math.rad ( 70 ) -- Field of view is measured in radians. local farPlane = 100 -- How far the camera can see. -- We'll place the camera 5 studs above the world origin. -- Because we're not defining a direction, the camera will be looking down the -Z axis. local CFrame = CFrame . new ( Vector3 . new ( 0 , 5 , 0 )) -- Create the camera. local myCamera = RayTracingCamera . new ( resolution , fieldOfView , farPlane , CFrame ) -- We won't be defining shaders just yet, so we don't need to pass any parameters except the camera. local myRayTracer = RayTracer . new ( myCamera , 1 , { SkyShader , TestShader }) local image = myRayTracer : Render () function showImage ( image ) for x = 1 , # image do for y = 1 , # image [ x ] do local pixel = Instance . new ( \"Part\" ) pixel . Size = Vector3 . new ( 1 , 1 , 0 ) pixel . Position = Vector3 . new ( x , resolution . Y - y , - resolution . X ) - Vector3 . new ( resolution . X / 2 , resolution . Y / 2 , 0 ) pixel . Anchored = true pixel . CanCollide = false pixel . CanTouch = false pixel . CanQuery = false pixel . CastShadow = false pixel . Locked = true pixel . Color = image [ x ][ y ] pixel . Material = Enum . Material . SmoothPlastic pixel . Parent = workspace end end end showImage ( image ) Let's see what the result looks like. Finally the image is starting to look a little bit more what we expected. Note For more advanced sky effects such as time of day, you can simply add the necessary code to the sky shader.","title":"Sky shaders"},{"location":"getting-started/sky-shaders/#sky-shaders","text":"In the previous part we created a shader that displayed the color of an object if a ray hits it. If a ray didn't hit anything, no shader was applied, resulting in the sky appearing as magenta. Let's create a shader that is only applied if a ray doesn't hit anything. Just like before, we'll define the shader in a ModuleScript located in the shaders folder. -- ModuleScript local Shader = require ( script . Parent . Parent . classes . Shader ) local SkyShader = Shader . new () -- Define the function of the shader. SkyShader . Function = function ( Ray , Hit , ...) -- If the ray hit something, skip this shader. if Hit then return end -- Let's return a solid light blue color to represent the sky. return Color3 . new ( 0.5 , 0.5 , 1 ) end return SkyShader Now let's add the sky shader to our ray tracer. First we'll have to require the shader in our main script. local SkyShader = require ( package . shaders . SkyShader ) Just like we did with the first shader, we'll replace the current Ray Tracer definition with our new one. This time we'll include both the sky shader and the first shader. local myRayTracer = RayTracer . new ( myCamera , 1 , { SkyShader , TestShader }) Full script so far 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 local RayTracingCamera = require ( package . classes . RayTracingCamera ) local RayTracer = require ( package . classes . RayTracer ) local TestShader = require ( package . shaders . TestShader ) local SkyShader = require ( package . shaders . SkyShader ) -- We'll use a resolution of 100x100 to avoid having to wait too long for the render to complete. local resolution = Vector2 . new ( 100 , 100 ) local fieldOfView = math.rad ( 70 ) -- Field of view is measured in radians. local farPlane = 100 -- How far the camera can see. -- We'll place the camera 5 studs above the world origin. -- Because we're not defining a direction, the camera will be looking down the -Z axis. local CFrame = CFrame . new ( Vector3 . new ( 0 , 5 , 0 )) -- Create the camera. local myCamera = RayTracingCamera . new ( resolution , fieldOfView , farPlane , CFrame ) -- We won't be defining shaders just yet, so we don't need to pass any parameters except the camera. local myRayTracer = RayTracer . new ( myCamera , 1 , { SkyShader , TestShader }) local image = myRayTracer : Render () function showImage ( image ) for x = 1 , # image do for y = 1 , # image [ x ] do local pixel = Instance . new ( \"Part\" ) pixel . Size = Vector3 . new ( 1 , 1 , 0 ) pixel . Position = Vector3 . new ( x , resolution . Y - y , - resolution . X ) - Vector3 . new ( resolution . X / 2 , resolution . Y / 2 , 0 ) pixel . Anchored = true pixel . CanCollide = false pixel . CanTouch = false pixel . CanQuery = false pixel . CastShadow = false pixel . Locked = true pixel . Color = image [ x ][ y ] pixel . Material = Enum . Material . SmoothPlastic pixel . Parent = workspace end end end showImage ( image ) Let's see what the result looks like. Finally the image is starting to look a little bit more what we expected. Note For more advanced sky effects such as time of day, you can simply add the necessary code to the sky shader.","title":"Sky shaders"},{"location":"getting-started/tutorial-setup/","text":"Tutorial setup The following sections will guide you through the process of creating shaders and rendering images using Luau Ray Tracer. Before you get started, it is recommended you perform the following steps to set up a suitable test environment. Create a new empty Baseplate project. Add the Luau Ray Tracer package to your project. Save often! Accidentally starting a highly complex render may result in a crash. It is recommended that you learn to use the Luau Ray Tracer API before adding it to any live projects. Disclaimer This tutorial is provided as a guide only. It is not intended to be a complete reference for the Luau Ray Tracer API. For a complete reference, please refer to the API reference.","title":"Tutorial setup"},{"location":"getting-started/tutorial-setup/#tutorial-setup","text":"The following sections will guide you through the process of creating shaders and rendering images using Luau Ray Tracer. Before you get started, it is recommended you perform the following steps to set up a suitable test environment. Create a new empty Baseplate project. Add the Luau Ray Tracer package to your project. Save often! Accidentally starting a highly complex render may result in a crash. It is recommended that you learn to use the Luau Ray Tracer API before adding it to any live projects.","title":"Tutorial setup"},{"location":"getting-started/tutorial-setup/#disclaimer","text":"This tutorial is provided as a guide only. It is not intended to be a complete reference for the Luau Ray Tracer API. For a complete reference, please refer to the API reference.","title":"Disclaimer"}]}